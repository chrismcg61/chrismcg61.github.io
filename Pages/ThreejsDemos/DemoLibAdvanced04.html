<!DOCTYPE html>
<html>
<body>
<head>
	<title>THREEJS DemoLib Advanced 04</title>
</head>

<script src="https://cdn.rawgit.com/chrismcg61/TechDemos/r252/MyLibs/ThreeMin/My3D.js"></script>
<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.rawgit.com/mrdoob/three.js/r157/build/three.module.js",
      "three/addons/": "https://cdn.rawgit.com/mrdoob/three.js/r157/examples/jsm/"
    }
  }
</script>
  

  
<div>☰☰☰☰☰ vertexShader : </div>
<textarea id="myTxtArea" name="" rows="20" cols="110">
  MY TEXT
</textarea>
	


  
  
<script type="module">
import * as __THREE from 'three';
import Stats from 'three/addons/libs/stats.module.js';
import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
//
var POSTFX = {};
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
{
  POSTFX.EffectComposer = EffectComposer
  POSTFX.RenderPass = RenderPass
}
import { SSRPass } from 'three/addons/postprocessing/SSRPass.js';
import { ReflectorForSSRPass } from 'three/addons/objects/ReflectorForSSRPass.js';
{
  POSTFX.SSRPass = SSRPass
  POSTFX.ReflectorForSSRPass = ReflectorForSSRPass
}
import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';


var stats = new Stats();  document.body.appendChild( stats.dom );
var params = {
  folder1:"INIT_CONFIG", Scene1Factor:0.99,Scene2Factor:0.1,RENDER_FX:true,fxSelect:12, 
  folder2:"SCENE", ReInit:ReInit, meshNb:950,meshDetail:1, castShadow:true, backCol:0x008888,dirLightCol:0x888888,camLightCol:0xffffff, pLightCamPosZ:0.9, camPosX:0,camPosY:4,camPosZ:5,
  folder3:"OBJ", speedFactor:0.01, objPosX:0,objPosY:0,objPosZ:0, 
}
var gui = new GUI();
MY3D.initGui(params, gui, {M0_Gamma:0,M1_ColorCorr:1,M2_Tone:2,M3_Bloom:3,M4_Bokeh:4,M5_Film:5,M6_DotScreen:6,M7_Color:7,M8_Vignette:8,M9_Output:9,M10_Fxaa:10,M11_Pixel:11,M12_Ssr:12,M13_None:13,})
gui.folders[0].close()
// gui.folders[1].close()

MY3D.HH=800;  MY3D.WW=MY3D.HH*1.3;
MY3D.initWebglRenderer(__THREE)



var vertexShader = 
`
  attribute vec3 color;
  //
  varying vec2 vUv;
  varying vec3 vColor;
  varying vec4 vPos;
  uniform float time;
  void main(){
   vUv = uv; 
   vColor = color; 
   vec4 posTemp = vec4( position, 1.0 );
   vPos = modelMatrix * posTemp; 
   
   float force = 0.5 + 0.5 * cos(vPos.x * 0.3);
   posTemp.z += 0.09 * force * posTemp.y*posTemp.y * sin(time);
   
   vec4 mvPosition = modelViewMatrix * vec4( posTemp.xyz, 1.0 );   

   gl_Position = projectionMatrix * mvPosition;
   vPos = modelMatrix * posTemp; 
  }
`;
myTxtArea.value = vertexShader
//
ReInit()
function ReInit() {
  MY3D.initSceneBackground()
  MY3D.initScene2()
  MY3D.composerInit( POSTFX, params )
  MY3D.addSsrGroundReflector(POSTFX)
  //
  scene.rotGroup = new THREE.Group();
  scene.add( scene.rotGroup )
  {
    ground.geometry = new THREE.PlaneGeometry(30,30, 90,90)
    
    addCurveTubeMesh()    
  }  
}


function addCurveTubeMesh() {
  class CustomSinCurve extends THREE.Curve {
    constructor( scale = 1 ) {
      super();
      this.scale = scale;
    }
    getPoint( t, optionalTarget = new THREE.Vector3() ) {
      const tx = 2*t*t*t  //Math.sint(t)
      const ty = 3*t
      const tz = 0
      return optionalTarget.set( tx, ty, tz ).multiplyScalar( this.scale );
    }
  }
  const path = new CustomSinCurve( 0.5 );
  const curveGeo = new THREE.TubeGeometry( path, 5, 0.05, 8, false );
  
  var clonedGeo = curveGeo.clone()
  clonedGeo.rotateY( Math.PI*2/3 )
  clonedGeo.scale( 1,1.5,1 )
  var clonedGeo2 = curveGeo.clone()
  clonedGeo2.rotateY( -Math.PI*2/3 )
  clonedGeo2.scale( 1,1.9,1 )
  var geoList = [ curveGeo,clonedGeo,clonedGeo2 ]
  const mergedGeometry = BufferGeometryUtils.mergeGeometries( geoList );    
  
  scene.myCustomMaterial = customMat()
  var mergedMesh = new THREE.Mesh(  mergedGeometry,  scene.myCustomMaterial );
  scene.add( mergedMesh );
  
  var worldGeoList = [  ]
  for ( var ii=0; ii<params.meshNb; ii++ ) {
    var newComplexGeo = mergedGeometry.clone()
    newComplexGeo.translate( sRand(25), 0, -rand(20) )
    // newComplexGeo.rotateY( rand(0.5) )
    worldGeoList.push( newComplexGeo )
  }
  const mergedGeoSystem = BufferGeometryUtils.mergeGeometries( worldGeoList );    
  var mergedMeshSystem = new THREE.Mesh(  mergedGeoSystem,  scene.myCustomMaterial );
  scene.add( mergedMeshSystem );
}

function customMat(){
  var myCustomMaterial = MY3D.newShaderMaterial()
  myCustomMaterial.vertexShader = myTxtArea.value  
  myCustomMaterial.uniforms.noiseScale.value = 0.002
  return myCustomMaterial
}



// var lastT = performance.now()  //ms since Page Load
animate();
function animate() {
  camPLight.rotation.y += 2*params.speedFactor  
  // camPLight.position.x = 0.05*Math.sin( 0.001*performance.now() )
  // scene.rotGroup.rotation.z += 5*params.speedFactor  
  scene.myCustomMaterial.uniforms.time.value += 0.1  
  {
    camera.position.set( params.camPosX, params.camPosY, params.camPosZ )  
    scene.background = new THREE.Color( params.backCol )
    directionalLight.color = new THREE.Color( params.dirLightCol )
    camPLight.position.z=params.pLightCamPosZ; camPLight.color=new THREE.Color(params.camLightCol); camPLight.castShadow=params.castShadow;
    scene.rotGroup.position.set( params.objPosX, params.objPosY, params.objPosZ )  
  }
  //
  stats.update()  
  MY3D.myRender_Advanced(params)
  // renderer.render( scene, camera );
  requestAnimationFrame( animate );
}
</script>


  
</body>
</html>
